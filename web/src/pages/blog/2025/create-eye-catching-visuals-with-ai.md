---
layout: ../../../layouts/blog-post.astro
title: ドット絵なアイキャッチを AI で作る機能を Roo Code で作ってみた雑記
emoji: 📚
date: 2025-03-02
eyecatch: blog-create-eye-catching-visuals-with-ai
tags:
  - AI
---

ドットなアイキャッチを作りたいとずっと思ってはいたので、 Roo Code を本格的に触る題材として作った。
最初の方の感想はその時にしか残せないので、さらに進む前にその過程のメモやら雑感やら考えていたことを書いたもの。
この記事のアイキャッチはデバッグに使っていたら愛着が湧いてしまったサイっぽいキャラクター。

## 前提

- AI Coding が初めてとかではなく、 GitHub Copilot の β に始まり Cursor Pro は 1 年くらい使っているし、 Cline 系も初めて触るとかではない
- Tier 4 の 3.7 Sonnet
- 素の Roo Code でどんなものかを試したかったので、 Code で書く以外は何もしていない、 rules やプロンプトをカスタマイズしていない
- 一部は Cursor を使っている

## 実装過程

パッとこうすればいいがあったわけではないので、ざっくりとした枠組みから作りはじめた。
ベースとなるコードは前回作った関連記事のアプリで、新しく作るのも面倒なのでここに継ぎ足す形に。

```
Workers AI を利用して、アイキャッチ画像を生成するようにします。まずは、どんな画像が作れるかを検証するための簡単アプリを  related-aritcles-worker に機能追加する形で作成してください。
以下の仕様を実現してください:

- `/create_eyecatch` エンドポイントを作成し、受け取った記事の本文から Workers AI を用いて画像を生成します
    - モデルには `@cf/black-forest-labs/flux-1-schnell` を使用します
    - モデルのドキュメントはこれです: https://developers.cloudflare.com/workers-ai/models/flux-1-schnell/
- index.html に記事の本文を送信できるフォームを新たに作成し、画像が生成できたら表示してください
```

とりあえず記事をそのまま Workers AI の画像生成に投げ込んでみた、それっぽいアプリは出来るが、生成がうまくいくはずもなく文字数オーバー。

ここであった主なやりとり:
- dev-server が起動できない
    - Dev Container で動かしているので `wranlger` の起動に `--ip` が必要で、 `package.json` の `script` には書いているんだけど頑なに無視する、 rules で制御できるといいんだろうか？
- ブラウザが起動できない
    - ちゃんとわかってないが Dev Container 使っているのでホストとのアーキテクチャの違いでうまくいっていないみたいな話、多分私が悪い


画像生成をキーワードで行うようにする:

```
`/create_eyecatch` での画像生成フローを改善します、以下のフローを実現してください。

- 画像生成より前に、 Text Generation なモデルを通して、記事からキーワードを抽出します
- モデルは @cf/meta/llama-3.3-70b-instruct-fp8-fast を使ってみてください: https://developers.cloudflare.com/workers-ai/models/llama-3.3-70b-instruct-fp8-fast/
- 抽出したキーワードと以下の固定のプロンプトを組み合わせて 2000 文字以内のプロンプトを @cf/meta/llama-3.3-70b-instruct-fp8-fast に作成させます
    - 「ブログのアイキャッチ、背景は単色、人間を含まない、アニメ調」
- 最終的なプロンプトを使って画像を生成します
```

実装自体は意図通りにやってくれる、ただし意図した画像はでない。プロンプトがゴミなので当たり前すぎる話ではある。ここでなんとなく Open AI の DALL-E を使ってみたくなったので、切り替えてみる。

```
現在画像生成を Cloudflare の Workers AI で行っていますが、これがうまくいっていないので OpenAI のものに置き換えます。

- プロンプト作成部分は現状を維持します
- 画像生成を DALL·E 3 を使った実装に置き換えてください
- APIKEY は後ほどこちらで設定するので env に OPENAI_API_KEY が設定されている前提で進めてください
```

サイズ固定が出来るようになって(Workers AI でも出来るものはある)、出力が安定した気がするがほしい感じの画像はまあでない。

## ロジックを見直す

記事内のキーワードからそれっぽい画像を作るのはなかなか厳しいことがわかったので、別の方法を考えた。
オライリーっぽい感じで、キーワードと動物を関連付けるのはどうかなと思いつつ適当に Sonnet と話していたら Sonnet もそう言っていたので、そうすることにした。
カテゴリごとに動物と背景色をざっくりと決めて、それをベースに作ってもらえるようにお願いするプロンプトを Sonnet と考える。

最終的にこんな感じに、オライリーのぱｋリスペクト、メンダコ(dumbo-octopus)は適当にメモにかわいいとか書いてたら Sonnet が入れた:

```
`/create_eyecatch` の既存のキーワード抽出および画像生成コードを活用・改良し、技術キーワードに対応するドット絵動物キャラクターをベースとしたブログ記事用アイキャッチ画像を生成するシステムを完成さてください。

## 実装内容
1. キーワード-動物マッピングシステムの拡張
以下のマッピングテーブルを既存コードに組み込む：

const techAnimalMap = {
  "cloudflare": { animal: "alpaca", backgroundColor: "#F38020" },
  "ai": { animal: "owl", backgroundColor: "#8A2BE2" },
  "javascript": { animal: "rhino", backgroundColor: "#F7DF1E" },
  "typescript": { animal: "guanaco", backgroundColor: "#3178C6" },
  "html": { animal: "koala", backgroundColor: "#E34F26" },
  "css": { animal: "fish", backgroundColor: "#1572B6" },
  "database": { animal: "dumbo-octopus", backgroundColor: "#336791" }
};

2. キーワード抽出ロジックの強化

既存のキーワード抽出コードを利用し、記事内容から上記に定義されたキーワードの出現頻度を分析
最も関連性の高いキーワードを特定するロジックを追加
複数の関連キーワードがある場合の優先順位付けメカニズムを実装
```

この辺から画像生成 AI に投げるプロンプトを私が読まなくなったので、全部英語に変えてもらった。プロンプトに更に注文をつけていく:

```
画像生成プロンプトを次のように改善して

- 8bitゲーム風のレトロな作風に
- キャラクター以外のアイコンやテキストを極力含まない
```
```
プロンプトを更に改善します

- キャラクターのドット絵には黒い縁をつける
```

他にも色々投げた気がしますが、かなりいい感じの画像が返ってくるようになった。最終的なプロンプトのコードはこんな感じ:

```ts
const variations = [
    "cute and playful",
    "simple and minimalist",
    "detailed and expressive",
    "cheerful and colorful",
    "cool and stylish"
];
const imageResponse = await openai.images.generate({
    model: "dall-e-3",
    prompt: `Create an 8-bit retro game style pixel art of a ${animal} character representing the concept of ${selectedTechKeyword} and ${keywordsString}.
    The character should be centered on a solid ${backgroundColor} background.
    Style: Classic 8-bit NES/Famicom era pixel art, extremely limited color palette (4-8 colors maximum), ${variations[index]}.
    IMPORTANT: The ${animal} character MUST have a black outline/border around it - this is essential for the retro game look.
    The black outline should be exactly 1 pixel thick and should completely surround the character.
    The ${animal} character should be the ONLY element in the image - no icons, symbols, text, UI elements, or any other objects.
    Make it look like a character sprite from an 80s video game with sharp pixels, no anti-aliasing.
    The final result should be clean, minimalist, and instantly recognizable as an 8-bit game character with a distinct black outline.
    The final image should be exactly 64x64 pixels in size.`,
    n: 1, // DALL-E 3では1枚ずつ生成
    size: "1024x1024", // DALL·E 3で利用可能なサイズ
    quality: "standard",
    response_format: "b64_json",
});
```

ネガティブっぽいプロンプトは書いても聞いてくれないどころか、書くとほぼ含めてくるようになるのでやめた。 `backgroundColor` はだいたい無視される。これを 5 リクエスト同時に投げて 5 枚づつ作るようにしている。

ちなみに適当に検証したタイミングで画像生成はやめて、開発中は適当に作ったものに固定すればよかったが、頭が回らずに無駄に $10 くらいクレジット溶かした(戒め1)。
あとこんな感じに、ちょっとうまくいったな！と思ったタイミングで絶対に git commit した方がいい(戒め2)。

## ドット絵にする、地獄の始まり

この手の画像の生成をやったことがある人は知っていると思うが、生成 AI が作るドット絵はドット絵ではない。わからないと何を言っているんだという感じだが、この記事のサムネの元になった画像を見てみるとわかりやすいと思う:

<img src="/images/create-eye-catching-visuals-with-ai-01.png" alt="original" />

パット見拡大されたドット絵に見えるが、斜めに切れているドットがあったり、1ドットの中に複数の色が存在したりしている。目とか耳を見るとドット絵としてはまぁない状態になっていることがわかりやすいはず。
これを補正して、うまくドット絵にするのが目標。ネタバレするとすべて機械化することは諦めて、最終的には人間が細かい修正をする形に落ち着いた。

さて、これをどう修正していくかというと、まずは範囲選択 → 選択した範囲を 128x128 px のドット絵と見立てる → それぞれのドットを一番多い色で塗りつぶす、というのを考えた。

```
自動生成したアイキャッチ用画像に簡単な加工が出来るようにします。これは、ブログ全体での画像のテイストをなるべく揃えるために必要な作業です。
次のような加工をしたいと考えています:

- 背景色を透過処理
- 生成された画像から、アイコン部分だけをユーザーが範囲選択して切り抜き
- 切り抜いた画像をニアレストネイバー法を用いて 128x128 に縮小
- 4倍である 512x512 に拡大、1ドット辺り 4x4 を利用する状態にする
- この画像を 1200x630 のキャンバスの真ん中に配置する
- キャンバスの背景を指定された 1 色で塗りつぶす

これを次のようなフローで実現したいと考えています:

- `/create_eyecatch` で候補となる画像を複数枚生成
- クライアントでユーザーが範囲指定して切り抜きを行う
- 縮小、拡大、補正を行ったキャラクターをユーザーが確認できる形で出力
- ユーザーが決定したら、1200x630のキャンバスに配置し、アイキャッチとして出力する

各ステップでキャンセルして先頭に戻せるようにしてください
```

結論からいうとこれは全くうまくいかなかった。望む状態になるよう何度か修正を加えたが、範囲選択ができ、切り抜きを行って 128x128 に縮小する... というところまではいくが、その画像が綺麗ではない。
そもそも生成された画像のドットのサイズがまちまちなので、固定値で出来るようなものでもなく、という感じ。
一方で全体の UI とフローというか、要素の配置があまりにも適当すぎる(これは指示を一切していないのも悪いが)ことを除けば、操作自体はそれっぽくできる、すごい。
ここで作ったドット絵化のロジックはすべて消えているが、 UI の枠組みはここで作ったものを最後まで使うことになった。

次にグリッドに区切ってそれぞれのドットを一番多い色で塗りつぶす、というのを考えた。イメージとしてはこんなの:

<img src="/images/create-eye-catching-visuals-with-ai-02.png" alt="original" />

```
index.html へ画像の加工機能を実装します、これは `/create_eyecatch` で生成された曖昧なドット絵(Pixel Art)をきれいなドット絵に加工し、最終的に 1200 x 630 のサイズにします。

## 前提
- `/create_eyecatch` で生成される画像は 1024x1024 px です
- そこに、拡大された 64x64 px 程度のドット絵が書かれています
- ただし、ドット絵としては歪みもある画像になっています
     - 例えば、拡大された一つの Dot を複数の色が構成しています
     - ドット絵には存在しないはずの、円形の Dot が存在します

## 実装する機能のフロー
ドット絵として不正な Dot を補正して、ドット絵を完成させます。

1. まず返却された複数の画像から一つをユーザーが選択します
2. 選択された画像にグリッドを表示します、このグリッドは 8 x 8 pxを 1 dot として扱います、言い換えると全体を 128 x 128 px のキャンバスだと見立てるということです
3. グリッドの大きさはスライダーでユーザーが調整できるようにします
4. ユーザーがグリッドのサイズを決定したら、画像を変更する処理に入ります
5. 処理した画像を出力します、1200 x 630 のキャンバスにはまだ入れる必要はありません

## 画像処理の詳細
ユーザーが決めたグリッドにそって、Dot の塗りつぶしを行います

- グリッドで区切られた Dot の中で、最も多く使われている色を計算します
- その色で、その Dot をすべて塗りつぶします
- 使った色を記録しておきます
- すべての Dot を塗りつぶしたあと、使った色の数が 16 種類以上ある場合、色を少なくする処理を行います
      - 近い色をまとめ、16 種類にします
      - まとめられた色を、まとめた色で置き換えます
      - 縁の装飾のため真っ黒(#000) は必ず残します
      - 最終的な色の分布が、同じ系統の色に偏らないようにしてください

この処理を行うことで、例えばグリッドのサイズが 8x8 px であれば、1024x1024 の画像が 128x128px のドット絵となることを期待します。
```

```
色の絞り込みのルールを変更します。

- 基本的には、使われている回数が多い順に採用し、16 色に収めます
- 人間が識別できない濃淡の差がある色がある場合は、それをまとめます
- この中に、四隅のそれぞれ 4 Dot の色は含まないでください
- 四隅の 4Dot と極めて近い色を持つ Dot はすべて同じ色にします
```

```
'related-articles-worker/public/index.html' (see below for file content) に実装されている画像編集機能をさらにパワーアップします。
既存のドットの補正、色の補正の処理が終わったあと、ユーザーがさらに修正を行い、最終的に 1200 x 630 の画像として出力します。
以下の機能を追加してください:

- 補正が終わった画像に対して、使われている色を利用して 1 Dot 単位の変更が出来る機能の追加
- 補正が終わった画像に対して、使われている色を利用して連なっている同色をすべて塗りつぶす機能の追加
- その後、画像の4隅の色と同じ色で塗りつぶした 1200x630 のキャンバスを用意し、任意の位置に加工済みの画像を配置できるようにする
- 背景色を変更できるようにする

## ユーザーによる画像の補正

- 利用している 16 色のパレットから、任意の色を選んで、
     - クリックした Dot をその色に置き換える事ができる
     - 連なっている同色を塗りつぶすことが出来る
          - 塗りつぶしツールを実装する
```

1 回では不足していたので、細かい修正依頼とかはしつつも大まかに 3 つのプロンプトで機能全体ができた。
これはこの時点でかなりいいものが出てきていて、なるべく脳をプロンプトに dump したかいがあったなと感じた。

<img src="/images/create-eye-catching-visuals-with-ai-03.png" alt="original" />
<img src="/images/create-eye-catching-visuals-with-ai-04.png" alt="original" />

これにグリッドのオフセットを付け加えたり、 Undo が出来るようにしたり、というのを対話で雑に加えていった。 Undo を作っている途中で一度コンテキストが足りなくなったので、新しいプロンプトで次の指示をしたらわりと察してやってくれた:

```
@/related-articles-worker/public/index.html にはドット絵を編集する機能がありますが、 undo 機能を実装する途中で止まってしまっています。
undo 機能を完成させてください。

- 10 回まで undo が出来る
-  ctrl + z をショートカットに設定する
```

このあたりから結構バグ修正というか、動作して気に入らなかったり、動いてなかったりというのを修正することが増えた。
あと、この機能の実装を全部 index.html 1 ファイルに詰め込んでいたので、 1 回で使うコンテキストの量があからさまに多くなってきた。

バグ修正の基本的なやりかたとしては、 UI が関わるものは気に入らない部分を SS して、文句と一緒に投げていた。これで基本的には解決してくれる。

<img src="/images/create-eye-catching-visuals-with-ai-05.png" alt="original" />
<img src="/images/create-eye-catching-visuals-with-ai-06.png" alt="original" />

唯一「グリッドと画像がずれる」という問題をどうしても Roo Code では解決できなくて、Cursor と解決した。

<img src="/images/create-eye-catching-visuals-with-ai-07.png" alt="original" />

この辺はいつもどおり Dev Tool からおかしい CSS やら調べたりということしていて、だいたいわかったところで原因がありそうな行を Cursor に投げて直してもらった。
Cursor で直したものは、動作の不具合としてはこれともう一つ。そっちは多分 Cursor でも出来たが、だいたい検討がついていたので Cursor に投げたほうが早いよなとなった。

実装をさらに進めていって、最終的な出力を調整出来る段階まで来たので、細かい位置やドットの大きさを指定できるようにしたい:

```
@/related-articles-worker/public/index.html のドット絵編集機能を改善します。最終的にアイキャッチとして 1200 x 630 px のサイズで画像を出力します。
以下の機能を実装します:

- 画像の倍率を調整する機能
- 画像の位置を中心からのオフセットで調整する機能
- 選択した色をすべて背景色として扱う機能

## 倍率を調整する機能

この編集機能はグリッドの大きさを設定することができます。
例えば 16px のグリッドを設定した場合、ドット絵として見た場合は 16x16 px が 1 ドットとして扱われるため、16倍に拡大された画像ということになります。
この倍率を最終的な出力では自由に調整できるようにして、画像の大きさを調整します。

次のように実現します:
- 1x 2x 4x 8x 16x のような刻みで倍率を選択出来るようにする
     - この倍率は、元画像からの倍率ではなく、ドット絵を 1 ドット = 1x1px に正規化した場合の倍率です
     - 例えば、16px のグリッドで作成された場合も 8x を選んだのであれば 1 ドットが 8x8px のグリッドで構成されるドット絵になります


## 選択した色をすべて背景色として扱う

最終的な出力の背景を単色としたいので、同一の色で塗りつぶす必要があります
加工中の画像の背景色はランダムなため、パレットから背景色として扱う色を複数個選べる必要があります
選んだ色と、1200x630 を確保して生まれた余剰部分の色をすべて同じにして、単色での背景を実現します
```

これだとドット絵をそのまま引き伸ばして悲しい感じの画像になっていたので、間違っているよといったら理解してくれた:

```
@/related-articles-worker/public/index.html でのドット絵編集の最終段階である 1200 x 630 でのアイキャッチ出力部分を改善します。
倍率を変更する際に、元々のグリッドと倍率が異なると色の境界がぼやけるようになっています。これは間違った実装です。
画像の引き伸ばしではなく、ドットのサイズのみを変更します。
```

### アップロードと配信部分を作る

生成するだけで配信をしていないので、作った画像を記事に関連付けて取れるようにする機能を足す。

```
@/related-articles-worker/src/index.ts にアイキャッチ画像を配信する機能を追加します。アイキャッチ画像は @/related-articles-worker/public/index.html で作成できるようになっています。
次のフローを実装してください:

1. `/registier` で登録されたとき、これまでの処理に追加して、id と本文の内容をセットで KV へ保存します
2. このとき、まだアイキャッチは作られていません
3. index.html で画像生成を開いたとき、まだアイキャッチのない記事の一覧を表示します
4. 記事を選ぶと、対象の id を `/create_eyecatch` に送り、既存のフローでアイキャッチを作成します
5. 作成したアイキャッチをアップロードするエンドポイントを新たに実装し、そこへアイキャッチを送信します
      - また、id を指定して画像をアップロードする方法も同時に用意してください
6. `/eyecatch?id=${id}` で、登録したアイキャッチが画像として返ってくるようにします

データストアが必要であれば、 Workers の KV を利用してください。
```

特に間違いもなく一瞬で終わる、 index.html がでかすぎて一度途切れたが、「以下のプロンプトではじめた実装の続きをしてください」 という指示で同じプロンプトを貼り付けたらうまいことしてくれた。
直接アップロードする機能とかも適当に開発させて終わり。書くことが特にない、こういうのが得意なのはそれはそうという感じ。

## 雑感

### まあ安くはない

差額で見た感じ、今回の機能を作るのに $25 くらいかかっていた。ここにすべてのプロンプトを載せているわけではない。
土日の可処分時間でやったもので、全部自分で書いたらこうはならなかったなと思うと時間を買えた感覚はあるのだが、今後の趣味の開発がこのペースで進むとして単純に 4 週で月 $100 + α。
ここに Cursor Pro と Claude Pro 、API と叩いているツールもろもろの利用料が乗ってなんやかんやで AI に掛かる費用が月 $200 くらいになるのかと思うとなかなか。

ただ、今回ちゃんとやるために Tier 4 に引き上げたが、 Tier 4 未満の Roo Code は考えられないのでやるならまず Tier 4 にした方がいい。低い Tier で使ったこともあり、そのときは微妙という感想だった。

### 自分でも曖昧な部分の開発が重い

これはわかっていた話というか、別に普段の開発でも変わらないところ。今回でいうとドット絵の編集。
完全に人間がやる場合と比べて、とりあえずプロンプトを書けば何かは出てくるので、それを触ってみて「やっぱだめだよな」が気軽にできるのはよかったと思う。
ので、別に AI も得意ではないけど、人間がやる理由にはならないとは思った。困ったらそれこそ Chat で相談とかでもよい。
ただ、これをやるのに、後述のセーブポイントはまじでたくさん作ったほうがいいと思った。

### コンテキストでかすぎ問題

これは index.html にすべての実装を乗せていったのが完全に悪いのだけど、最後の方は 2500 行程度になって 3 回往復したらコンテキストが足りなくなる、みたいになっていた。
後で実際のやりとりを除いてみると、ほぼ毎回 index.html をめちゃくちゃ送っている、でかい。ファイル指定しているからそりゃそう。

今回これを回避するのに、前のプロンプト貼り付けて「多分続きまでやってるからなんとかして」みたいな指示をしていた。
この進め方自体の是非はともかく、 Roo Code は結構察して進めてくれるので、素直にすごいなと思った。

コンテキストが足りるようにコードを適切に分割しろという話ではあって、コードのファイルを分ける基準が今後はわりとここに関係してきそうだなと思った。
今回 rules なんかは全く使っていなくてこれなので、改善できるんだろうなぁとは思いつつも、これ以上にコンテキストに何かを入れることが出来るのか...? という気持ちが強い。

### セーブポイントをたくさん作れ

git commit をたくさんしろ、というのとほぼイコール。
少しでも期待した動作になったり、進捗が出たと思ったらすぐに commit する癖をつけるのがいいと思った。
ここまでをなしにして実装をやり直したい、と思うことが結構あって、その時点で commit がなくて Roo Code の戻すのをお願いしたりしていた。虚無。

### プロンプトは適当でもわりとなんとかなる

ここの機能を実装したいときの指示書、みたいなものは結構適当でもいいなという感覚がある。最悪対話で修正すればよくて、これは Cursor でもそう感じていた。
ある程度フォーマット化されているのがいいとは思いつつも、曖昧なことやノイズが入っていなければなんとかなる、という印象。
それよりもコードベース全体を理解させることの方がはるかに重要だろうな、という感じ、そりゃそう。今回はほぼすべてが index.html だったので、逆にそこは解決されていた感があった。

### デザイン適当すぎ問題

これは何も指示していないのがだいたい悪いとは思うんだけど、誰が使えるんだその UI みたいなのが平気で出てくる、基本縦に長過ぎる。
