<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>関連記事API テスト</title>
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
        }
        input, textarea {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 1rem;
        }
        button {
            padding: 0.5rem 1rem;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0052a3;
        }
        .result {
            margin-top: 1rem;
            padding: 1rem;
            background: #f5f5f5;
            border-radius: 4px;
            white-space: pre-wrap;
        }
        .error {
            color: #dc2626;
        }
        /* 画像編集関連のスタイル */
        .editor-container {
            margin-top: 1rem;
            display: none;
        }
        .grid-controls {
            margin-bottom: 1rem;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }
        .slider-container label {
            margin-right: 1rem;
            margin-bottom: 0;
            min-width: 120px;
        }
        .slider-container input {
            flex-grow: 1;
            margin-bottom: 0;
        }
        .slider-value {
            margin-left: 1rem;
            min-width: 60px;
            text-align: right;
        }
        .canvas-container {
            position: relative;
            margin: 1rem 0;
            overflow: auto;
            max-height: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .editor-buttons {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
            padding: 0.5rem;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .color-swatch {
            width: 24px;
            height: 24px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>関連記事API テスト</h1>

    <section>
        <h2>記事の登録</h2>
        <form id="registerForm">
            <div class="form-group">
                <label for="apiKey">API Key:</label>
                <input type="password" id="apiKey" required>
            </div>
            <div class="form-group">
                <label for="articleId">記事ID:</label>
                <input type="text" id="articleId" required>
            </div>
            <div class="form-group">
                <label for="url">URL:</label>
                <input type="url" id="url" required>
            </div>
            <div class="form-group">
                <label for="content">記事の内容:</label>
                <textarea id="content" rows="4" required></textarea>
            </div>
            <button type="submit">登録</button>
        </form>
        <div id="registerResult" class="result"></div>
    </section>

    <section>
        <h2>関連記事の取得</h2>
        <form id="searchForm">
            <div class="form-group">
                <label for="searchId">記事ID:</label>
                <input type="text" id="searchId" required>
            </div>
            <button type="submit">検索</button>
        </form>
        <div id="searchResult" class="result"></div>
    </section>

    <section>
        <h2>アイキャッチ画像の生成</h2>
        <form id="eyecatchForm">
            <div class="form-group">
                <label for="eyecatchContent">記事の本文:</label>
                <textarea id="eyecatchContent" rows="4" required placeholder="画像を生成するための記事本文を入力してください"></textarea>
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="useTestImages"> テスト画像を使用する（APIを呼び出さない）
                </label>
            </div>
            <button type="submit">画像生成</button>
        </form>
        <div id="eyecatchResult" class="result">
            <div id="eyecatchLoading" style="display: none;">画像生成中...</div>
            <div id="eyecatchError" class="error" style="display: none;"></div>
            <div id="eyecatchImageContainer" style="margin-top: 1rem; text-align: center; display: none;">
                <h3>生成された画像（クリックして選択）</h3>
                <div id="imagesGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; margin-bottom: 1rem;"></div>
                <div id="selectedImageContainer" style="margin-top: 1rem; display: none;">
                    <h3>選択された画像</h3>
                    <img id="selectedImage" style="max-width: 100%; border: 2px solid #0066cc; border-radius: 4px;" />
                    <div style="margin-top: 0.5rem;">
                        <button id="downloadButton" style="background-color: #22c55e;">ダウンロード</button>
                        <button id="editButton" style="background-color: #0066cc; margin-left: 0.5rem;">画像を加工する</button>
                    </div>
                </div>

                <!-- 画像編集UI -->
                <div id="imageEditor" class="editor-container">
                    <h3>ドット絵加工</h3>
                    <div class="grid-controls">
                        <div class="slider-container">
                            <label for="gridSizeSlider">グリッドサイズ:</label>
                            <input type="range" id="gridSizeSlider" min="4" max="32" value="8" step="1">
                            <span id="gridSizeValue" class="slider-value">8px</span>
                        </div>
                        <div class="slider-container">
                            <label for="offsetXSlider">X方向オフセット:</label>
                            <input type="range" id="offsetXSlider" min="0" max="16" value="0" step="1">
                            <span id="offsetXValue" class="slider-value">0px</span>
                        </div>
                        <div class="slider-container">
                            <label for="offsetYSlider">Y方向オフセット:</label>
                            <input type="range" id="offsetYSlider" min="0" max="16" value="0" step="1">
                            <span id="offsetYValue" class="slider-value">0px</span>
                        </div>
                        <p>グリッドサイズは1ドットの大きさを表します。小さいほど細かいドット絵になります。オフセットはグリッドの開始位置をずらします。</p>
                    </div>

                    <div class="canvas-container">
                        <canvas id="imageCanvas"></canvas>
                        <canvas id="gridCanvas"></canvas>
                    </div>

                    <div class="editor-buttons">
                        <button id="processButton" style="background-color: #22c55e;">ドット絵に変換</button>
                        <button id="resetButton" style="background-color: #6b7280;">リセット</button>
                        <button id="downloadProcessedButton" style="background-color: #0066cc; display: none;">加工画像をダウンロード</button>
                    </div>

                    <div id="processedImageContainer" style="margin-top: 1rem; display: none;">
                        <h3>加工後の画像</h3>
                        <canvas id="processedCanvas"></canvas>
                    </div>

                    <div id="colorPaletteContainer" style="margin-top: 1rem; display: none;">
                        <h3>使用色パレット (<span id="colorCount">0</span>色)</h3>
                        <div id="colorPalette" class="color-palette"></div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <script>
        // 記事登録フォームの処理
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const resultDiv = document.getElementById('registerResult');

            try {
                const response = await fetch('/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': document.getElementById('apiKey').value
                    },
                    body: JSON.stringify({
                        id: document.getElementById('articleId').value,
                        url: document.getElementById('url').value,
                        content: document.getElementById('content').value
                    })
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || '登録に失敗しました');
                }

                resultDiv.textContent = '登録成功！';
                resultDiv.classList.remove('error');
            } catch (error) {
                resultDiv.textContent = `エラー: ${error.message}`;
                resultDiv.classList.add('error');
            }
        });

        // 関連記事検索フォームの処理
        document.getElementById('searchForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const resultDiv = document.getElementById('searchResult');

            try {
                const id = document.getElementById('searchId').value;
                const response = await fetch(`/related_articles?id=${encodeURIComponent(id)}`);
                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || '検索に失敗しました');
                }

                resultDiv.textContent = JSON.stringify(result, null, 2);
                resultDiv.classList.remove('error');
            } catch (error) {
                resultDiv.textContent = `エラー: ${error.message}`;
                resultDiv.classList.add('error');
            }
        });

        // アイキャッチ画像生成フォームの処理
        document.getElementById('eyecatchForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const resultDiv = document.getElementById('eyecatchResult');
            const loadingDiv = document.getElementById('eyecatchLoading');
            const errorDiv = document.getElementById('eyecatchError');
            const imageContainer = document.getElementById('eyecatchImageContainer');
            const imagesGrid = document.getElementById('imagesGrid');
            const selectedImageContainer = document.getElementById('selectedImageContainer');
            const selectedImage = document.getElementById('selectedImage');
            const downloadButton = document.getElementById('downloadButton');

            // 表示状態をリセット
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
            imageContainer.style.display = 'none';
            imagesGrid.innerHTML = '';
            selectedImageContainer.style.display = 'none';

            try {
                const content = document.getElementById('eyecatchContent').value;
                const useTestImages = document.getElementById('useTestImages').checked;

                let result;

                if (useTestImages) {
                    // テスト画像を使用する場合
                    // Base64エンコードされた画像データを取得する関数
                    const getBase64Image = async (imagePath) => {
                        return new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = 'Anonymous';
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                const dataURL = canvas.toDataURL('image/png');
                                resolve(dataURL.replace(/^data:image\/(png|jpg);base64,/, ''));
                            };
                            img.onerror = () => reject(new Error('画像の読み込みに失敗しました'));
                            img.src = imagePath;
                        });
                    };

                    try {
                        // テスト用の5つの画像を読み込む
                        const imagePromises = [];
                        for (let i = 1; i <= 5; i++) {
                            imagePromises.push(getBase64Image(`/image${i}.png`));
                        }

                        const imageDataArray = await Promise.all(imagePromises);

                        // テスト用のレスポンスを作成
                        result = {
                            success: true,
                            images: imageDataArray,
                            keywords: 'テスト, JavaScript, React, Node.js',
                            selectedTechKeyword: 'JavaScript',
                            animal: 'Fox',
                            backgroundColor: '#f0f0f0'
                        };
                    } catch (error) {
                        throw new Error('テスト画像の読み込みに失敗しました: ' + error.message);
                    }
                } else {
                    // 通常のAPI呼び出し
                    const response = await fetch('/create_eyecatch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ content })
                    });

                    result = await response.json();

                    if (!response.ok) {
                        throw new Error(result.error || '画像生成に失敗しました');
                    }
                }

                if (result.success && result.images && result.images.length > 0) {
                    // 技術キーワードと動物の情報を表示
                    const infoElement = document.createElement('div');
                    infoElement.style.marginBottom = '1rem';
                    infoElement.innerHTML = `
                        <p><strong>検出されたキーワード:</strong> ${result.keywords}</p>
                        <p><strong>選択された技術:</strong> ${result.selectedTechKeyword}</p>
                        <p><strong>動物キャラクター:</strong> ${result.animal}</p>
                        <p><strong>背景色:</strong> <span style="display: inline-block; width: 20px; height: 20px; background-color: ${result.backgroundColor}; vertical-align: middle; margin-right: 5px;"></span> ${result.backgroundColor}</p>
                    `;
                    imagesGrid.appendChild(infoElement);

                    // 各画像をグリッドに表示
                    result.images.forEach((imageData, index) => {
                        const imageCard = document.createElement('div');
                        imageCard.style.border = '1px solid #ddd';
                        imageCard.style.borderRadius = '4px';
                        imageCard.style.padding = '0.5rem';
                        imageCard.style.cursor = 'pointer';
                        imageCard.style.transition = 'transform 0.2s';

                        const img = document.createElement('img');
                        img.src = `data:image/png;base64,${imageData}`;
                        img.style.width = '100%';
                        img.style.borderRadius = '4px';
                        img.alt = `生成画像 ${index + 1}`;

                        const caption = document.createElement('p');
                        caption.textContent = `バリエーション ${index + 1}`;
                        caption.style.textAlign = 'center';
                        caption.style.marginTop = '0.5rem';

                        imageCard.appendChild(img);
                        imageCard.appendChild(caption);

                        // 画像クリック時の処理
                        imageCard.addEventListener('click', () => {
                            // すべてのカードの選択状態をリセット
                            document.querySelectorAll('#imagesGrid > div').forEach(card => {
                                card.style.border = '1px solid #ddd';
                                card.style.transform = 'scale(1)';
                            });

                            // 選択したカードをハイライト
                            imageCard.style.border = '2px solid #0066cc';
                            imageCard.style.transform = 'scale(1.02)';

                            // 選択した画像を表示
                            selectedImage.src = img.src;
                            selectedImageContainer.style.display = 'block';

                            // ダウンロードボタンの設定
                            downloadButton.onclick = () => {
                                const link = document.createElement('a');
                                link.href = img.src;
                                link.download = `eyecatch-${result.selectedTechKeyword}-${result.animal}-${index + 1}.png`;
                                link.click();
                            };
                        });

                        imagesGrid.appendChild(imageCard);
                    });

                    imageContainer.style.display = 'block';
                } else {
                    throw new Error('画像データが見つかりません');
                }
            } catch (error) {
                errorDiv.textContent = `エラー: ${error.message}`;
                errorDiv.style.display = 'block';
            } finally {
                loadingDiv.style.display = 'none';
            }
        });

        // 画像編集機能の実装
        document.addEventListener('DOMContentLoaded', () => {
            // 編集ボタンのクリックイベント
            if (document.getElementById('editButton')) {
                document.getElementById('editButton').addEventListener('click', () => {
                    const selectedImage = document.getElementById('selectedImage');
                    const imageEditor = document.getElementById('imageEditor');

                    if (selectedImage && selectedImage.src && imageEditor) {
                        // 画像編集UIを表示
                        imageEditor.style.display = 'block';

                        // キャンバスの初期化
                        initializeCanvas(selectedImage.src);
                    } else {
                        alert('画像が選択されていません。');
                    }
                });
            }

            // スライダーの処理
            const gridSizeSlider = document.getElementById('gridSizeSlider');
            const gridSizeValue = document.getElementById('gridSizeValue');
            const offsetXSlider = document.getElementById('offsetXSlider');
            const offsetXValue = document.getElementById('offsetXValue');
            const offsetYSlider = document.getElementById('offsetYSlider');
            const offsetYValue = document.getElementById('offsetYValue');

            // グリッドサイズスライダーの処理
            if (gridSizeSlider && gridSizeValue) {
                gridSizeSlider.addEventListener('input', () => {
                    const value = gridSizeSlider.value;
                    gridSizeValue.textContent = `${value}px`;

                    // オフセットの最大値をグリッドサイズに合わせて調整
                    const maxOffset = parseInt(value) - 1;
                    offsetXSlider.max = maxOffset;
                    offsetYSlider.max = maxOffset;

                    // 現在の値が新しい最大値を超えている場合は調整
                    if (parseInt(offsetXSlider.value) > maxOffset) {
                        offsetXSlider.value = maxOffset;
                        offsetXValue.textContent = `${maxOffset}px`;
                    }

                    if (parseInt(offsetYSlider.value) > maxOffset) {
                        offsetYSlider.value = maxOffset;
                        offsetYValue.textContent = `${maxOffset}px`;
                    }

                    drawGrid();
                });
            }

            // X方向オフセットスライダーの処理
            if (offsetXSlider && offsetXValue) {
                offsetXSlider.addEventListener('input', () => {
                    const value = offsetXSlider.value;
                    offsetXValue.textContent = `${value}px`;
                    drawGrid();
                });
            }

            // Y方向オフセットスライダーの処理
            if (offsetYSlider && offsetYValue) {
                offsetYSlider.addEventListener('input', () => {
                    const value = offsetYSlider.value;
                    offsetYValue.textContent = `${value}px`;
                    drawGrid();
                });
            }

            // 処理ボタンのクリックイベント
            const processButton = document.getElementById('processButton');
            if (processButton) {
                processButton.addEventListener('click', processImage);
            }

            // リセットボタンのクリックイベント
            const resetButton = document.getElementById('resetButton');
            if (resetButton) {
                resetButton.addEventListener('click', () => {
                    const selectedImage = document.getElementById('selectedImage');
                    if (selectedImage && selectedImage.src) {
                        initializeCanvas(selectedImage.src);

                        // 処理後の画像を非表示
                        const processedImageContainer = document.getElementById('processedImageContainer');
                        const colorPaletteContainer = document.getElementById('colorPaletteContainer');
                        const downloadProcessedButton = document.getElementById('downloadProcessedButton');

                        if (processedImageContainer) processedImageContainer.style.display = 'none';
                        if (colorPaletteContainer) colorPaletteContainer.style.display = 'none';
                        if (downloadProcessedButton) downloadProcessedButton.style.display = 'none';
                    }
                });
            }

            // 処理済み画像ダウンロードボタンのクリックイベント
            const downloadProcessedButton = document.getElementById('downloadProcessedButton');
            if (downloadProcessedButton) {
                downloadProcessedButton.addEventListener('click', () => {
                    const processedCanvas = document.getElementById('processedCanvas');
                    if (processedCanvas) {
                        const link = document.createElement('a');
                        link.href = processedCanvas.toDataURL('image/png');
                        link.download = 'processed-pixel-art.png';
                        link.click();
                    }
                });
            }
        });

        // グローバル変数
        let originalImageData = null;
        let imageCanvas = null;
        let imageCtx = null;
        let gridCanvas = null;
        let gridCtx = null;

        // キャンバスの初期化
        function initializeCanvas(imageSrc) {
            imageCanvas = document.getElementById('imageCanvas');
            gridCanvas = document.getElementById('gridCanvas');

            if (!imageCanvas || !gridCanvas) return;

            imageCtx = imageCanvas.getContext('2d');
            gridCtx = gridCanvas.getContext('2d');

            const img = new Image();
            img.onload = function() {
                // キャンバスのサイズを画像に合わせる
                imageCanvas.width = img.width;
                imageCanvas.height = img.height;
                gridCanvas.width = img.width;
                gridCanvas.height = img.height;

                // 画像を描画
                imageCtx.drawImage(img, 0, 0);

                // 元の画像データを保存
                originalImageData = imageCtx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);

                // グリッドを描画
                drawGrid();
            };
            img.src = imageSrc;
        }

        // グリッドの描画
        function drawGrid() {
            if (!gridCanvas || !gridCtx || !imageCanvas) return;

            // グリッドをクリア
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            const gridSize = parseInt(document.getElementById('gridSizeSlider').value);
            const offsetX = parseInt(document.getElementById('offsetXSlider').value);
            const offsetY = parseInt(document.getElementById('offsetYSlider').value);
            const width = imageCanvas.width;
            const height = imageCanvas.height;

            gridCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            gridCtx.lineWidth = 1;

            // 縦線を描画（オフセットを考慮）
            for (let x = offsetX; x <= width; x += gridSize) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, height);
                gridCtx.stroke();
            }

            // 横線を描画（オフセットを考慮）
            for (let y = offsetY; y <= height; y += gridSize) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(width, y);
                gridCtx.stroke();
            }
        }

        // 画像処理
        function processImage() {
            if (!imageCanvas || !imageCtx || !originalImageData) return;

            const gridSize = parseInt(document.getElementById('gridSizeSlider').value);
            const offsetX = parseInt(document.getElementById('offsetXSlider').value);
            const offsetY = parseInt(document.getElementById('offsetYSlider').value);
            const width = imageCanvas.width;
            const height = imageCanvas.height;

            // 元の画像データを復元
            imageCtx.putImageData(originalImageData, 0, 0);

            // 処理用のキャンバスを作成
            const processedCanvas = document.getElementById('processedCanvas');
            if (!processedCanvas) return;

            const processedCtx = processedCanvas.getContext('2d');
            processedCanvas.width = width;
            processedCanvas.height = height;

            // 元の画像を処理用キャンバスにコピー
            processedCtx.drawImage(imageCanvas, 0, 0);

            // 使用した色を記録するオブジェクト（色 -> 使用回数）
            const colorUsage = {};

            // 四隅の色を記録する配列
            const cornerColors = [];

            // グリッドごとに処理（オフセットを考慮）
            for (let y = offsetY; y < height; y += gridSize) {
                for (let x = offsetX; x < width; x += gridSize) {
                    // グリッド内の画素を取得
                    const gridWidth = Math.min(gridSize, width - x);
                    const gridHeight = Math.min(gridSize, height - y);

                    const imageData = processedCtx.getImageData(x, y, gridWidth, gridHeight);
                    const data = imageData.data;

                    // 色の出現回数をカウント
                    const colorCount = {};

                    for (let i = 0; i < data.length; i += 4) {
                        // 完全な透明ピクセルはスキップ
                        if (data[i + 3] === 0) continue;

                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const colorKey = `${r},${g},${b}`;

                        colorCount[colorKey] = (colorCount[colorKey] || 0) + 1;
                    }

                    // 最も多く使われている色を見つける
                    let maxCount = 0;
                    let dominantColorKey = '0,0,0'; // デフォルトは黒

                    for (const colorKey in colorCount) {
                        if (colorCount[colorKey] > maxCount) {
                            maxCount = colorCount[colorKey];
                            dominantColorKey = colorKey;
                        }
                    }

                    // 色をRGB配列に変換
                    const [r, g, b] = dominantColorKey.split(',').map(Number);

                    // グリッド全体を支配的な色で塗りつぶす
                    processedCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    processedCtx.fillRect(x, y, gridWidth, gridHeight);

                    // 使用した色を記録
                    const colorHex = rgbToHex(r, g, b);
                    colorUsage[colorHex] = (colorUsage[colorHex] || 0) + 1;

                    // 四隅の色を記録
                    const isCorner = (
                        (x === offsetX && y === offsetY) || // 左上
                        (x === offsetX && y >= height - gridSize) || // 左下
                        (x >= width - gridSize && y === offsetY) || // 右上
                        (x >= width - gridSize && y >= height - gridSize) // 右下
                    );

                    if (isCorner && !cornerColors.includes(colorHex)) {
                        cornerColors.push(colorHex);
                    }
                }
            }

            // 使用した色の配列を作成
            const usedColors = Object.keys(colorUsage);

            // 色の数を減らす処理
            let finalColors = usedColors;
            if (usedColors.length > 16) {
                finalColors = reduceColors(usedColors, cornerColors);

                // 画像の色を置き換える
                const fullImageData = processedCtx.getImageData(0, 0, width, height);
                const fullData = fullImageData.data;

                for (let i = 0; i < fullData.length; i += 4) {
                    const r = fullData[i];
                    const g = fullData[i + 1];
                    const b = fullData[i + 2];
                    const originalHex = rgbToHex(r, g, b);

                    // 最も近い色を見つける
                    const closestColor = findClosestColor(originalHex, finalColors);
                    const [newR, newG, newB] = hexToRgb(closestColor);

                    fullData[i] = newR;
                    fullData[i + 1] = newG;
                    fullData[i + 2] = newB;
                }

                processedCtx.putImageData(fullImageData, 0, 0);
            }

            // 色パレットを表示
            displayColorPalette(finalColors);

            // 処理後の画像を表示
            document.getElementById('processedImageContainer').style.display = 'block';
            document.getElementById('colorPaletteContainer').style.display = 'block';
            document.getElementById('downloadProcessedButton').style.display = 'inline-block';

            // 色の数を表示
            document.getElementById('colorCount').textContent = finalColors.length;
        }

        // 色パレットの表示
        function displayColorPalette(colors) {
            const paletteContainer = document.getElementById('colorPalette');
            if (!paletteContainer) return;

            paletteContainer.innerHTML = '';

            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                paletteContainer.appendChild(swatch);
            });
        }

        // 色の数を減らす処理
        function reduceColors(colors, cornerColors) {
            // 黒色は必ず残す
            const blackColor = '#000000';
            let reducedColors = colors.includes(blackColor) ? [blackColor] : [];

            // 色の使用頻度を取得
            const colorUsage = {};
            for (const color of colors) {
                colorUsage[color] = colorUsage[color] || 0;
            }

            // 四隅の色とその近似色を特定
            const cornerColorGroups = {};
            for (const cornerColor of cornerColors) {
                cornerColorGroups[cornerColor] = [cornerColor];

                // 四隅の色と極めて近い色を見つける（色の距離が閾値以下）
                const similarityThreshold = 30; // 色の距離の閾値
                for (const color of colors) {
                    if (color === cornerColor) continue;

                    const distance = colorDistance(color, cornerColor);
                    if (distance < similarityThreshold) {
                        cornerColorGroups[cornerColor].push(color);
                    }
                }
            }

            // 四隅の色とその近似色を除外した残りの色
            const remainingColors = colors.filter(color => {
                for (const cornerColor in cornerColorGroups) {
                    if (cornerColorGroups[cornerColor].includes(color)) {
                        return false;
                    }
                }
                return color !== blackColor;
            });

            // 人間が識別できない濃淡の差がある色をまとめる
            const colorClusters = [];
            const processedColors = new Set();

            for (const color of remainingColors) {
                if (processedColors.has(color)) continue;

                const cluster = [color];
                processedColors.add(color);

                // 非常に近い色をクラスタリング
                const similarityThreshold = 15; // 色の距離の閾値
                for (const otherColor of remainingColors) {
                    if (color === otherColor || processedColors.has(otherColor)) continue;

                    const distance = colorDistance(color, otherColor);
                    if (distance < similarityThreshold) {
                        cluster.push(otherColor);
                        processedColors.add(otherColor);
                    }
                }

                // クラスタ内で最も使用頻度が高い色を代表色として選択
                let representativeColor = cluster[0];
                let maxUsage = colorUsage[representativeColor] || 0;

                for (const clusterColor of cluster) {
                    const usage = colorUsage[clusterColor] || 0;
                    if (usage > maxUsage) {
                        maxUsage = usage;
                        representativeColor = clusterColor;
                    }
                }

                colorClusters.push({
                    color: representativeColor,
                    usage: maxUsage
                });
            }

            // 使用頻度に基づいてクラスタをソート
            colorClusters.sort((a, b) => b.usage - a.usage);

            // 最大16色になるまで色を追加（黒を含む）
            for (const cluster of colorClusters) {
                if (reducedColors.length >= 16) break;
                reducedColors.push(cluster.color);
            }

            return reducedColors;
        }

        // 最も近い色を見つける
        function findClosestColor(targetColor, colorPalette) {
            let minDistance = Infinity;
            let closestColor = colorPalette[0];

            for (const color of colorPalette) {
                const distance = colorDistance(targetColor, color);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }

            return closestColor;
        }

        // 色の距離を計算（ユークリッド距離）
        function colorDistance(color1, color2) {
            const [r1, g1, b1] = hexToRgb(color1);
            const [r2, g2, b2] = hexToRgb(color2);

            return Math.sqrt(
                Math.pow(r1 - r2, 2) +
                Math.pow(g1 - g2, 2) +
                Math.pow(b1 - b2, 2)
            );
        }

        // RGB値を16進数カラーコードに変換
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // 16進数カラーコードをRGB値に変換
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0];
        }

        // 16進数カラーコードをHSL値に変換
        function hexToHsl(hex) {
            const [r, g, b] = hexToRgb(hex).map(x => x / 255);

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // 無彩色
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }

                h = h * 60;
            }

            return [h, s, l];
        }
    </script>
</body>
</html>
